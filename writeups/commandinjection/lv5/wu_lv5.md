# Command Injection Level 5

## __1. Sử dụng như người dùng:__
Mình sử dụng lại payload của lv4 nhưng không còn cú POST nào gửi đến server Webhook nữa.  
Và giao diện sử dụng vẫn như ở lv4

## __2. Xem đằng sau chương trình:__
Ở file `index.php` thì vẫn không có gì thay đổi nhưng lúc này lại có thêm file file `nginx.conf`
```nginx
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    server_tokens off;

    location / {
        proxy_pass http://level05;
    }
}
```
Ở file này cấu hình có firewall sẽ điều hướng vào trang web chứ không còn là mình vào thẳng trang web nữa.  
```docker
level05-proxy:
    image: nginx:stable
    ports:
      - "3005:80"
    volumes:
      - ./cmdi_level5/config/nginx.conf:/etc/nginx/conf.d/default.conf
    restart: always
    networks:
      - internet
      - no-internet
  level05:
    build: ./cmdi_level5
    container_name: 'cmdi_level05'
    restart: 'unless-stopped'
    volumes: 
      - ./cmdi_level5/src/index.php:/var/www/html/index.php
    networks:
      - no-internet
```
Tiếp tục xem vào file `docker-compose.yml` ở `level5-proxy` thì đích thị anh Devops đã dùng proxy chặn ngay giữa để chặn kết nối ra ngoài internet ở `networks: - no-internet`

## __3. Lên ý tưởng và Khai thác:__
### a. <ins>Ý tưởng</ins>:
Level này khác với level 4 ở chỗ: server đã bị chặn kết nối ra ngoài internet, nên ta không hteer gửi output ra server của attacker như lv4.  
Tuy Server bị chặn đường ra ngoài internet nhưng server không bị chặn đường vào, ta vẫn có thể truy cập đến server thông qua đường web (giao thức HTTP).  
Liệu ta có thể tận dụng con đường này để đọc output của command?

&rarr; Ta tận dụng quy tắc của HTTPd, dùng command để ghi output vào 1 file trong `Document Root` và nhờ HTTPd đọc file đó lên trang web.

### b. <ins>Khai thác</ins>:
Lúc này mình sẽ truy cập vào `bash` của `cointainer lv5` để có thể dễ dàng kiểm chứng cho những việc làm sắp tới.  

![](1.PNG)  
Lúc này trong `Document Root` chỉ có mỗi file `index.php`.  
Mình thử sử dụng 1 Injection đơn giản vào `target` 
```cmd
; echo "hacked" >> test.txt #
```
Quay lại xem trong thư mục `Document Root` thì đã ghi được file `test.txt` nhờ vào payload ở trên và nội dung file như mình đã truyền vào  
![](2.PNG)  
Và mình mở file `test.txt` trên trình duyệt  
![](3.PNG)  
&rarr; Mình đã có thể đọc và ghi file thành công. Và mình có thể RCE Server để lấy `flag` thôi.

__Payload:__  
```cmd
; cat /*.txt > flag.txt #
```
![](4.PNG)
> CBJS{FAKE_FLAG_FAKE_FLAG}
